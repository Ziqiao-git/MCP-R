{
  "qualifiedName": "@whit3rabbit/specforged",
  "displayName": "SpecForged",
  "description": "Create and evolve clear software specifications from requirements and design to implementation planning and execution. Use a guided wizard to progress through phases, generate actionable task plans, and track progress and dependencies. Integrate with your project files to keep requirements, designs, and tasks aligned.",
  "iconUrl": "https://spjawbfpwezjfmicopsl.supabase.co/storage/v1/object/public/server-icons/e5e233ce-ee1e-47e9-aeca-3caee5306ad4.png",
  "remote": true,
  "deploymentUrl": "https://server.smithery.ai/@whit3rabbit/specforged",
  "security": null,
  "tools": [
    {
      "name": "classify_mode",
      "description": "\nClassify user input to determine routing mode.\nReturns confidence scores for chat, do, and spec modes.\n",
      "inputSchema": {
        "type": "object",
        "title": "classify_modeArguments",
        "required": [
          "user_input"
        ],
        "properties": {
          "user_input": {
            "type": "string",
            "title": "User Input"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "classify_modeOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "create_spec",
      "description": "\nCreate a new specification with requirements, design, and tasks files.\nAutomatically sets it as the current specification.\n\nArgs:\n    name: A descriptive name for the specification.\n    description: A brief description of the specification's purpose.\n    spec_id: A short, unique identifier (e.g., 'frontend', 'refactor-api').\n             If not provided, it will be generated from the name.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "create_specArguments",
        "required": [
          "name"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "description": {
            "type": "string",
            "title": "Description",
            "default": ""
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "create_specOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "set_current_spec",
      "description": "\nSet the active specification for subsequent commands.\n\nArgs:\n    spec_id: The identifier of the specification to make active.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "set_current_specArguments",
        "required": [
          "spec_id"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "set_current_specOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "add_requirement",
      "description": "\nAdd a user story with EARS-formatted acceptance criteria to the\nspecification. Uses the current spec if spec_id is omitted.\n\nArgs:\n    as_a: The user role (for user story)\n    i_want: The desired functionality (for user story)\n    so_that: The benefit/reason (for user story)\n    spec_id: The specification identifier. If omitted, uses the current spec.\n    ears_requirements: List of EARS requirements with 'condition'\n        and 'system_response'\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "add_requirementArguments",
        "required": [
          "as_a",
          "i_want",
          "so_that"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "as_a": {
            "type": "string",
            "title": "As A"
          },
          "i_want": {
            "type": "string",
            "title": "I Want"
          },
          "so_that": {
            "type": "string",
            "title": "So That"
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "ears_requirements": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Ears Requirements",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "add_requirementOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "update_design",
      "description": "\nUpdate the technical design documentation for a specification.\nUses the current spec if spec_id is omitted.\n\nArgs:\n    spec_id: The specification identifier. If omitted, uses the current spec.\n    architecture: System architecture description\n    components: List of components with name and description\n    data_models: TypeScript/interface definitions\n    sequence_diagrams: List of diagrams with title and mermaid\n        content\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "update_designArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "components": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Components",
            "default": null
          },
          "data_models": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Data Models",
            "default": null
          },
          "architecture": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Architecture",
            "default": null
          },
          "sequence_diagrams": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Sequence Diagrams",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "update_designOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "list_specifications",
      "description": "\nList all available specifications with their current status and phase,\nhighlighting the current one.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "list_specificationsArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "list_specificationsOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "check_initialization_status",
      "description": "\nCheck if SpecForge is initialized and provide guidance for next steps.\nDetects missing .specifications folder, empty specifications, or incomplete\nphases.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "check_initialization_statusArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "check_initialization_statusOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "get_specification_details",
      "description": "\nGet detailed information about a specific specification.\n\nArgs:\n    spec_id: The specification identifier\n    include_content: Whether to include full content of requirements,\n        design, and tasks\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "get_specification_detailsArguments",
        "required": [
          "spec_id"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          },
          "include_content": {
            "type": "boolean",
            "title": "Include Content",
            "default": false
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "get_specification_detailsOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "start_wizard_mode",
      "description": "\nStart the SpecForge project wizard for comprehensive specification creation.\n\nThis wizard guides you through Requirements → Design → Planning phases\nvia conversation, using MCP tools to build your specification.\n\nArgs:\n    project_name: Name of the project/feature to create\n    description: Brief description of what you're building\n    auto_detect_folder: Whether to check for existing specifications folder\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "start_wizard_modeArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "description": {
            "type": "string",
            "title": "Description",
            "default": ""
          },
          "project_name": {
            "type": "string",
            "title": "Project Name",
            "default": ""
          },
          "auto_detect_folder": {
            "type": "boolean",
            "title": "Auto Detect Folder",
            "default": true
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "start_wizard_modeOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "wizard_next_step",
      "description": "\nGet guidance for the next step in the wizard for a specification.\n\nArgs:\n    spec_id: The specification identifier\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "wizard_next_stepArguments",
        "required": [
          "spec_id"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "wizard_next_stepOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "wizard_complete_phase",
      "description": "\nMark a wizard phase as complete and get guidance for the next phase.\n\nArgs:\n    spec_id: The specification identifier\n    phase: Phase to mark complete ('requirements', 'design', 'planning')\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "wizard_complete_phaseArguments",
        "required": [
          "spec_id",
          "phase"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "phase": {
            "type": "string",
            "title": "Phase"
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "wizard_complete_phaseOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "add_implementation_task",
      "description": "\nAdd an implementation task to the specification's task list.\nUses the current spec if spec_id is omitted.\n\nArgs:\n    title: Task title\n    description: Detailed task description\n    spec_id: The specification identifier. If omitted, uses the\n        current spec.\n    dependencies: List of task IDs this task depends on\n    subtasks: List of subtask descriptions\n    linked_requirements: List of requirement IDs this task\n        implements\n    estimated_hours: Estimated hours for completion\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "add_implementation_taskArguments",
        "required": [
          "title",
          "description"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "title": {
            "type": "string",
            "title": "Title"
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "subtasks": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Subtasks",
            "default": null
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "dependencies": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Dependencies",
            "default": null
          },
          "estimated_hours": {
            "type": "number",
            "title": "Estimated Hours",
            "default": 0
          },
          "linked_requirements": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Linked Requirements",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "add_implementation_taskOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "execute_task",
      "description": "\nExecute a specific task from the specification.\n\nIMPORTANT: Loads requirements.md and design.md context before\nexecution. Updates task status and provides execution details with\nproper context. Uses the current spec if spec_id is omitted.\n\nArgs:\n    task_id: The task identifier to execute\n    spec_id: The specification identifier. If omitted, uses the\n        current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "execute_taskArguments",
        "required": [
          "task_id"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "task_id": {
            "type": "string",
            "title": "Task Id"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "execute_taskOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "transition_workflow_phase",
      "description": "\nTransition the specification to a new workflow phase.\nUses the current spec if spec_id is omitted.\n\nValid phases: requirements, design, implementation_planning,\nexecution, review, completed\n\nArgs:\n    target_phase: The target workflow phase\n    spec_id: The specification identifier. If omitted, uses the\n        current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "transition_workflow_phaseArguments",
        "required": [
          "target_phase"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "target_phase": {
            "type": "string",
            "title": "Target Phase"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "transition_workflow_phaseOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "get_next_available_tasks",
      "description": "\nGet tasks that are ready to be worked on (all dependencies\ncompleted). Uses the current spec if spec_id is omitted.\n\nArgs:\n    spec_id: The specification identifier. If omitted, uses the\n        current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "get_next_available_tasksArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "get_next_available_tasksOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "generate_implementation_plan",
      "description": "\nGenerate a comprehensive implementation plan from requirements and design.\nCreates a hierarchical task structure with checkbox format.\nUses the current spec if spec_id is omitted.\n\nArgs:\n    spec_id: The specification identifier. If omitted, uses the current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "generate_implementation_planArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "generate_implementation_planOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "update_implementation_plan",
      "description": "\nUpdate existing implementation plan based on changes to requirements or design.\nPreserves completion status of existing tasks.\nUses the current spec if spec_id is omitted.\n\nArgs:\n    spec_id: The specification identifier. If omitted, uses the current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "update_implementation_planArguments",
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "update_implementation_planOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "check_task",
      "description": "\nMark a task as completed (check the checkbox).\nAutomatically updates parent task status if all subtasks are complete.\nUses the current spec if spec_id is omitted.\n\nArgs:\n    task_number: The hierarchical task number (e.g., \"1\", \"2.1\", \"3.2.1\")\n    spec_id: The specification identifier. If omitted, uses the current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "check_taskArguments",
        "required": [
          "task_number"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "task_number": {
            "type": "string",
            "title": "Task Number"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "check_taskOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "uncheck_task",
      "description": "\nMark a task as pending (uncheck the checkbox).\nUpdates parent task status accordingly.\nUses the current spec if spec_id is omitted.\n\nArgs:\n    task_number: The hierarchical task number (e.g., \"1\", \"2.1\", \"3.2.1\")\n    spec_id: The specification identifier. If omitted, uses the current spec.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "uncheck_taskArguments",
        "required": [
          "task_number"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Spec Id",
            "default": null
          },
          "task_number": {
            "type": "string",
            "title": "Task Number"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "uncheck_taskOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "get_task_details",
      "description": "\nGet detailed information about a specific task.\n\nArgs:\n    spec_id: The specification identifier\n    task_number: The hierarchical task number (e.g., \"1\", \"2.1\", \"3.2.1\")\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "get_task_detailsArguments",
        "required": [
          "spec_id",
          "task_number"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          },
          "task_number": {
            "type": "string",
            "title": "Task Number"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "get_task_detailsOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "get_task_status_summary",
      "description": "\nSummarize task statuses for a spec, grouped by completed,\nin_progress, and pending.\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "get_task_status_summaryArguments",
        "required": [
          "spec_id"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "get_task_status_summaryOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "bulk_check_tasks",
      "description": "\nMark multiple tasks as completed.\nRequires either an explicit list of task_numbers or all_tasks=True.\n\nArgs:\n    spec_id: The specification identifier\n    task_numbers: List like [\"1\", \"2.1\", \"3.2.1\"]\n    all_tasks: If True, completes all tasks in the spec\n",
      "inputSchema": {
        "type": "object",
        "$defs": {
          "Context": {
            "type": "object",
            "title": "Context",
            "properties": {},
            "description": "Context object providing access to MCP capabilities.\n\nThis provides a cleaner interface to MCP's RequestContext functionality.\nIt gets injected into tool and resource functions that request it via type hints.\n\nTo use context in a tool function, add a parameter with the Context type annotation:\n\n```python\n@server.tool()\ndef my_tool(x: int, ctx: Context) -> str:\n    # Log messages to the client\n    ctx.info(f\"Processing {x}\")\n    ctx.debug(\"Debug info\")\n    ctx.warning(\"Warning message\")\n    ctx.error(\"Error message\")\n\n    # Report progress\n    ctx.report_progress(50, 100)\n\n    # Access resources\n    data = ctx.read_resource(\"resource://data\")\n\n    # Get request info\n    request_id = ctx.request_id\n    client_id = ctx.client_id\n\n    return str(x)\n```\n\nThe context parameter name can be anything as long as it's annotated with Context.\nThe context is optional - tools that don't need it can omit the parameter."
          }
        },
        "title": "bulk_check_tasksArguments",
        "required": [
          "spec_id"
        ],
        "properties": {
          "ctx": {
            "anyOf": [
              {
                "$ref": "#/$defs/Context"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "spec_id": {
            "type": "string",
            "title": "Spec Id"
          },
          "all_tasks": {
            "type": "boolean",
            "title": "All Tasks",
            "default": false
          },
          "task_numbers": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Numbers",
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "bulk_check_tasksOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "read_file",
      "description": "\nRead the content of a file within the project directory.\n\nArgs:\n    path: Relative or absolute path to the file (must resolve\n        under project root).\n",
      "inputSchema": {
        "type": "object",
        "title": "read_fileArguments",
        "required": [
          "path"
        ],
        "properties": {
          "path": {
            "type": "string",
            "title": "Path"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "read_fileOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "create_directory",
      "description": "\nCreate a directory within the project directory (recursively).\n\nArgs:\n    path: Relative or absolute directory path (must resolve\n        under project root).\n    exist_ok: If True (default), do not error if directory already exists.\n",
      "inputSchema": {
        "type": "object",
        "title": "create_directoryArguments",
        "required": [
          "path"
        ],
        "properties": {
          "path": {
            "type": "string",
            "title": "Path"
          },
          "exist_ok": {
            "type": "boolean",
            "title": "Exist Ok",
            "default": true
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "create_directoryOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "write_file",
      "description": "\nWrite or append UTF-8 text to a file within the project directory.\nCreates the file and parent directories if they don't exist.\n\nArgs:\n    path: Relative or absolute path to the file (must resolve\n        under project root).\n    content: Text to write.\n    mode: 'rewrite' (default) to overwrite, 'append' to append.\n",
      "inputSchema": {
        "type": "object",
        "title": "write_fileArguments",
        "required": [
          "path",
          "content"
        ],
        "properties": {
          "mode": {
            "type": "string",
            "title": "Mode",
            "default": "rewrite"
          },
          "path": {
            "type": "string",
            "title": "Path"
          },
          "content": {
            "type": "string",
            "title": "Content"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "write_fileOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "edit_block",
      "description": "\nReplace a specific block of text in a file within the project directory.\n\nArgs:\n    file_path: Path to the file to edit (must resolve under project\n        root).\n    old_string: Exact string to be replaced.\n    new_string: Replacement string.\n    expected_replacements: Expected number of occurrences to replace\n        (default: 1).\n",
      "inputSchema": {
        "type": "object",
        "title": "edit_blockArguments",
        "required": [
          "file_path",
          "old_string",
          "new_string"
        ],
        "properties": {
          "file_path": {
            "type": "string",
            "title": "File Path"
          },
          "new_string": {
            "type": "string",
            "title": "New String"
          },
          "old_string": {
            "type": "string",
            "title": "Old String"
          },
          "expected_replacements": {
            "type": "integer",
            "title": "Expected Replacements",
            "default": 1
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "edit_blockOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "object",
            "title": "Result",
            "additionalProperties": true
          }
        }
      }
    }
  ],
  "connections": [
    {
      "type": "http",
      "deploymentUrl": "https://server.smithery.ai/@whit3rabbit/specforged/mcp",
      "configSchema": {
        "type": "object",
        "required": [],
        "properties": {
          "spec_folder": {
            "type": "string",
            "default": ".specifications",
            "description": "Specifications folder name within project"
          },
          "project_path": {
            "type": "string",
            "default": ".",
            "description": "Project root path relative to deployment environment"
          },
          "enable_filesystem_tools": {
            "type": "boolean",
            "default": false,
            "description": "Enable filesystem modification tools (disabled for cloud deployment)"
          },
          "mode_classification_enabled": {
            "type": "boolean",
            "default": true,
            "description": "Enable intelligent mode classification for user requests"
          }
        }
      }
    }
  ]
}